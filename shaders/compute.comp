#version 450

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

// See https://community.khronos.org/t/drawing-to-image-from-compute-shader-example/7116/2
//layout ( binding = 0, rgba8 ) uniform writeonly image2D out_image;
layout(binding = 0, rgba8) uniform image2D inout_image;

struct Sphere
{
	vec4 center;
	vec4 albedo;
	float radius;
};

layout(binding = 1) uniform UniformBufferObject
{
	Sphere spheres[4];
} ubo;

layout(push_constant) uniform PushConstantBlock 
{
	uint progression_index; 
	float delta_time; 
} PushConstants;

struct Ray
{
	vec3 origin;
	vec3 dir;
};

// Evaluates the R2 sequence described in
// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/
// Implementation inspired by https://www.pouet.net/topic.php?which=11501&page=1#c546333
vec2 eval_r2_sequence(uint sample_index)
{
	const float PLASTIC_CONSTANT = 1.32471795f;
	return fract(float(sample_index) * vec2(1.0 / PLASTIC_CONSTANT, 1.0 / (PLASTIC_CONSTANT * PLASTIC_CONSTANT)));
}

void make_primary_ray(vec2 offset, out Ray out_ray)
{
	// These could come from push constants or a uniform buffer.
	const vec2 screen_dims = vec2(imageSize(inout_image));
	const float eye_dist = 2;

	const vec2 this_pixel = vec2(gl_WorkGroupID.x, gl_WorkGroupID.y) - vec2(0.5) + offset;
	const float center_pixel_dx = (2 * this_pixel.x + 1) / screen_dims.x - 1;
	const float center_pixel_dy = (screen_dims.y / screen_dims.x) * (2 * this_pixel.y + 1 - screen_dims.y) / screen_dims.y;

	out_ray.origin = vec3(0);
	out_ray.dir = vec3(center_pixel_dx, center_pixel_dy, -2);
}

/*
bool hit_sphere(vec3 center, float radius, Ray ray)
{
	vec3 oc = ray.origin - center;
	float a = dot(ray.dir, ray.dir);
	float b = 2 * dot(oc, ray.dir);
	float c = dot(oc, oc) - radius * radius;
	float discriminant = b*b - 4*a*c;
	return (discriminant > 0);
}
*/

float hit_sphere_shape(vec3 center, float radius, Ray r)
{
	vec3 oc = r.origin - center;
	float a = dot(r.dir, r.dir);
	float b = 2 * dot(oc, r.dir);
	float c = dot(oc, oc) - radius*radius;
	float discriminant = b*b - 4*a*c;
	if (discriminant < 0) {
		return -1;
	} else {
		return (-b - sqrt(discriminant)) / (2 * a);
	}
}

struct HitRecord
{
	vec4 albedo;
	float distance;
};

bool test_sphere(Sphere sphere, Ray r, out HitRecord out_hit_record)
{
	float d = hit_sphere_shape(sphere.center.xyz, sphere.radius, r);
	if (d >= 0) {
		out_hit_record = HitRecord(sphere.albedo, d);
		return true;
	}
	return false;
}

vec3 get_world_color(Ray ray)
{
	vec3 color = vec3(1.0);

	//Sphere sphere = Sphere(vec4(0, 0, -2, 1), vec4(1, 0.7, 0, 1), 0.5);

	Sphere sphere = ubo.spheres[0];

	HitRecord hit;
	if (test_sphere(sphere, ray, hit)) {
		color = hit.albedo.rgb;
	}

	/*
	if (hit_sphere_shape(vec3(0, 0, -2), 0.5, ray) >= 0) {
		color = vec3(1, 0.7, 0);
	}
	*/
	return color;
}


void main()
{
	const ivec2 screen_size = imageSize(inout_image);
	const ivec2 this_pixel = ivec2(gl_WorkGroupID.x, gl_WorkGroupID.y);

	Ray ray;

	vec2 offset = eval_r2_sequence(PushConstants.progression_index);
	//make_primary_ray(vec2(0, 0), ray);
	make_primary_ray(offset, ray);

	vec3 color = get_world_color(ray);

	vec4 accum_color = imageLoad(inout_image, this_pixel);
	// Branchless condition: if we just started a progression, we treat
	// the accumulation count as 0. This will overwrite the full result with our
	// color, saving us an image clear.
	float accum_count = accum_color.a * float(PushConstants.progression_index > 0);

	vec3 new_accum_rgb = (accum_count * accum_color.rgb + color) / (accum_count + 1);
	imageStore(inout_image, this_pixel, vec4(new_accum_rgb, accum_count + 1));
}

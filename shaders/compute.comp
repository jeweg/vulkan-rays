#version 450

#include "common.comp"

struct Sphere
{
	vec4 center_and_radius;
	vec4 albedo_and_roughness;
	vec4 emissive;
	vec4 specular_and_coefficient;
};

layout(binding = 1) uniform UniformBufferObject
{
	Sphere spheres[6];
} ubo;


// Only writes to out_hit_record if there's a hit. Always returns the hit distance or INF_DIST.
void test_sphere(Sphere sphere, Ray ray, float max_distance, out HitRecord out_hit_record)
{
	float d = hit_sphere_shape(sphere.center_and_radius.xyz, sphere.center_and_radius.w, ray);
	if (d >= 0 && d < max_distance) {
		vec3 pt = d * ray.dir + ray.origin;
		out_hit_record.pt = pt;
		out_hit_record.normal = normalize(pt - sphere.center_and_radius.xyz);
		out_hit_record.albedo_and_roughness = sphere.albedo_and_roughness;
		out_hit_record.emissive = sphere.emissive.rgb;
		out_hit_record.specular_and_coefficient = sphere.specular_and_coefficient;
		out_hit_record.dist = d;
	} else {
		out_hit_record.dist = INF_DIST;
	}
}


void intersect_ray_with_world(Ray ray, out HitRecord hit_record)
{
	hit_record.dist = INF_DIST;
	float closest_dist = INF_DIST;
	for (int i = 0; i < 6; ++i) {
		HitRecord hr;
		test_sphere(ubo.spheres[i], ray, closest_dist, hr);
		if (hr.dist < closest_dist) {
			closest_dist = hr.dist;
			hit_record = hr;
		}
	}
}


vec3 compute_color_for_ray(Ray ray)
{
	const int MAX_BOUNCE_COUNT = 10;
	vec3 remaining_weight = vec3(1);
	vec3 result = vec3(0);

	for (int bounce = 0; bounce < MAX_BOUNCE_COUNT; ++bounce) {

		HitRecord hit_record;
		intersect_ray_with_world(ray, hit_record);

		if (hit_record.dist == INF_DIST) {
			// We hit the environment.
			vec3 sky_color = mix(vec3(0, 0, 0.4), vec3(0.7, 0.7, 1), normalize(ray.dir).y * 0.5 + vec3(0.5));
			result += 0.2 * (sky_color * remaining_weight);
			break;
		}

		result += hit_record.emissive * remaining_weight;

		if (bounce + 1 == MAX_BOUNCE_COUNT) {
			break;
		}

		// Make a new ray for the next iteration.

		float do_specular = float(random_float_01(rng_state) <= hit_record.specular_and_coefficient.w);

		vec3 ray_dir_diffuse = hit_record.normal + random_unit_vector(rng_state);
		vec3 ray_dir_specular = reflect(ray.dir, hit_record.normal);

		// Square roughness as usual. We might as well put it squared into the ubo, but let's
		// keep it here for now for clarity.
		float roughness = hit_record.albedo_and_roughness.w * hit_record.albedo_and_roughness.w;

		ray_dir_specular = mix(ray_dir_specular, ray_dir_diffuse, roughness);

		ray.dir = mix(ray_dir_diffuse, ray_dir_specular, do_specular);
		ray.origin = hit_record.pt + hit_record.normal * RAY_START_BIAS;

		remaining_weight *= mix(hit_record.albedo_and_roughness.xyz, hit_record.specular_and_coefficient.xyz, do_specular);

		// Terminate rays early by playing russian roulette.
		float russian_roulette_prob = max(remaining_weight.x, max(remaining_weight.y, remaining_weight.z));
		if (russian_roulette_prob < random_float_01(rng_state)) {
			break;
		}
		// Increase remaining weights to make up for the impact of terminated rays.
		remaining_weight *= 1 / russian_roulette_prob;

		// Terminate rays early when the maximum impact of further rays goes below a threshold.
		if (all(lessThan(remaining_weight, vec3(0.005)))) {
			break;
		}
	}
	return result;
}


void main()
{
	init_rng();
	const ivec2 screen_size = imageSize(inout_image);
	const ivec2 this_pixel = ivec2(gl_WorkGroupID.x, gl_WorkGroupID.y);

	Ray ray;

	const uint progression_index = PushConstants.progression_index;

	vec2 offset = eval_r2_sequence(progression_index);
	make_primary_ray(offset, ray);

	vec3 color = compute_color_for_ray(ray);
	color = ACESFilm(color);

	vec4 accum_color = imageLoad(inout_image, this_pixel);
	// Branchless condition: if we just started a progression, we treat
	// the accumulation count as 0. This will overwrite the full result with our
	// color, saving us an image clear.
	float accum_count = accum_color.a * float(progression_index > 0);
	vec3 new_accum_rgb = (accum_count * accum_color.rgb + color) / (accum_count + 1);
	new_accum_rgb = min(new_accum_rgb, vec3(1));

	// Not that we can output linear color. We render into an sRGB attachment
	// and get the conversion for free.
	imageStore(inout_image, this_pixel, vec4(new_accum_rgb, accum_count + 1));
}

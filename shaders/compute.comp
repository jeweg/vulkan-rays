#version 450

#include "common.comp"

struct Sphere
{
	vec4 center_and_radius;
	vec4 albedo_and_roughness;
	vec4 emissive_and_ior;
	vec4 specular_and_coefficient;
};

layout(binding = 1) uniform UniformBufferObject
{
	float exposure;
	bool apply_aces;
	float gamma_factor;
	Sphere spheres[6];
} ubo;


// Only writes to out_hit_record if there's a hit. Always returns the hit distance or INF_DIST.
void test_sphere(Sphere sphere, Ray ray, float max_distance, out HitRecord out_hit_record)
{
	float d = hit_sphere_shape(sphere.center_and_radius.xyz, sphere.center_and_radius.w, ray);
	if (d >= 0 && d < max_distance) {
		vec3 pt = d * ray.dir + ray.origin;
		out_hit_record.pt = pt;
		out_hit_record.normal = normalize(pt - sphere.center_and_radius.xyz);
		out_hit_record.albedo_and_roughness = sphere.albedo_and_roughness;
		out_hit_record.emissive_and_ior = sphere.emissive_and_ior;
		out_hit_record.specular_and_coefficient = sphere.specular_and_coefficient;
		out_hit_record.dist = d;
	} else {
		out_hit_record.dist = INF_DIST;
	}
}


void intersect_ray_with_world(Ray ray, out HitRecord hit_record)
{
	hit_record.dist = INF_DIST;
	float closest_dist = INF_DIST;
	for (int i = 0; i < 6; ++i) {
		HitRecord hr;
		test_sphere(ubo.spheres[i], ray, closest_dist, hr);
		if (hr.dist < closest_dist) {
			closest_dist = hr.dist;
			hit_record = hr;
		}
	}
}


vec3 compute_color_for_ray(Ray ray)
{
	const int MAX_BOUNCE_COUNT = 10;
	vec3 remaining_weight = vec3(1);
	vec3 result = vec3(0);

	for (int bounce = 0; bounce < MAX_BOUNCE_COUNT; ++bounce) {

		HitRecord hit_record;
		intersect_ray_with_world(ray, hit_record);

		if (hit_record.dist == INF_DIST) {
			// We hit the environment.
			vec3 sky_color = mix(vec3(0, 0, 0.2), vec3(0.7, 0.6, 1), normalize(ray.dir).y * 0.5 + vec3(0.3));
			result += 0.2 * (sky_color * remaining_weight);
			break;
		}

		result += hit_record.emissive_and_ior.xyz * remaining_weight;

		if (bounce + 1 == MAX_BOUNCE_COUNT) {
			break;
		}

		// Make a new ray for the next iteration.

		float specular_chance = hit_record.specular_and_coefficient.w;
		if (specular_chance > 0) {
			specular_chance = compute_fresnel_reflect_amount(1.0, hit_record.emissive_and_ior.w, normalize(ray.dir), hit_record.normal, 
				hit_record.specular_and_coefficient.w, 1);
		}
		float do_specular = float(random_float_01(rng_state) <= specular_chance);

		// get the probability for choosing the ray type we chose
		float ray_probability = (do_specular == 1.0f) ? specular_chance : 1.0f - specular_chance; 
		// avoid numerical issues causing a divide by zero, or nearly so (more important later, when we add refraction)
		ray_probability = max(ray_probability, 0.001f);  

		vec3 ray_dir_diffuse = hit_record.normal + random_unit_vector(rng_state);
		vec3 ray_dir_specular = reflect(ray.dir, hit_record.normal);

		// Square roughness as usual. We might as well put it squared into the ubo, but let's
		// keep it here for now for clarity.
		float roughness = hit_record.albedo_and_roughness.w * hit_record.albedo_and_roughness.w;

		ray_dir_specular = mix(ray_dir_specular, ray_dir_diffuse, roughness);

		ray.dir = mix(ray_dir_diffuse, ray_dir_specular, do_specular);
		ray.origin = hit_record.pt + hit_record.normal * RAY_START_BIAS;

		remaining_weight *= mix(hit_record.albedo_and_roughness.xyz, hit_record.specular_and_coefficient.xyz, do_specular);

		// since we chose randomly between diffuse and specular,
		// we need to account for the times we didn't do one or the other.
		remaining_weight /= ray_probability;

		// Terminate rays early by playing russian roulette.
		float russian_roulette_prob = max(remaining_weight.x, max(remaining_weight.y, remaining_weight.z));
		if (russian_roulette_prob < random_float_01(rng_state)) {
			break;
		}
		// Increase remaining weights to make up for the impact of terminated rays.
		remaining_weight *= 1 / russian_roulette_prob;

		// Terminate rays early when the maximum impact of further rays goes below a threshold.
		if (all(lessThan(remaining_weight, vec3(0.005)))) {
			break;
		}
	}
	return result;
}


void main()
{
	init_rng();
	const ivec2 screen_size = imageSize(inout_image);
	const ivec2 this_pixel = ivec2(gl_WorkGroupID.x, gl_WorkGroupID.y);

	Ray ray;

	const uint progression_index = PushConstants.progression_index;

	vec2 offset = eval_r2_sequence(progression_index);
	make_primary_ray(offset, ray);

	vec3 linear_color = compute_color_for_ray(ray);


	// Apply Reinhard tone mapping
	linear_color *= ubo.exposure;
	linear_color = linear_color / (vec3(1.0) + linear_color);

	if (ubo.apply_aces) {
		// Apply ACES tone mapping
		linear_color = aces_tone_mapping(linear_color);
	}

	// Apply a gamma correction. Since we output linear color into an sRGB target,
	// the system will apply proper gamma correction. We can effectively modify
	// that system gamma with a factor (applying pow(color, 1/gamma) twice will
	// result in pow(color, 1/(system_gamma * gamma_factor))).
	linear_color = pow(linear_color, vec3(1.0 / ubo.gamma_factor));

	vec4 accum_color = imageLoad(inout_image, this_pixel);
	// Branchless condition: if we just started a progression, we treat
	// the accumulation count as 0. This will overwrite the full result with our
	// color, saving us an image clear.
	float accum_count = accum_color.a * float(progression_index > 0);
	vec3 new_accum_rgb = (accum_count * accum_color.rgb + linear_color) / (accum_count + 1);
	new_accum_rgb = min(new_accum_rgb, vec3(1));

	// Not that we can output linear color. We render into an sRGB attachment
	// and get the conversion for free.
	imageStore(inout_image, this_pixel, vec4(new_accum_rgb, accum_count + 1));
}

#version 450

#include "common.comp"

struct Sphere
{
	vec4 center_and_radius;
	vec4 albedo;
	vec4 emissive;
};

layout(binding = 1) uniform UniformBufferObject
{
	Sphere spheres[6];
} ubo;


// Only writes to out_hit_record if there's a hit. Always returns the hit distance or INF_DIST.
void test_sphere(Sphere sphere, Ray ray, float max_distance, out HitRecord out_hit_record)
{
	float d = hit_sphere_shape(sphere.center_and_radius.xyz, sphere.center_and_radius.w, ray);
	if (d >= 0 && d < max_distance) {
		vec3 pt = d * ray.dir + ray.origin;
		out_hit_record.pt = pt;
		out_hit_record.normal = normalize(pt - sphere.center_and_radius.xyz);
		out_hit_record.albedo = sphere.albedo.rgb;
		out_hit_record.emissive = sphere.emissive.rgb;
		out_hit_record.dist = d;
	} else {
		out_hit_record.dist = INF_DIST;
	}
}


void intersect_ray_with_world(Ray ray, out HitRecord hit_record)
{
	hit_record.dist = INF_DIST;
	float closest_dist = INF_DIST;
	for (int i = 0; i < 6; ++i) {
		HitRecord hr;
		test_sphere(ubo.spheres[i], ray, closest_dist, hr);
		if (hr.dist < closest_dist) {
			closest_dist = hr.dist;
			hit_record.pt = hr.pt;
			hit_record.normal = hr.normal;
			hit_record.albedo = hr.albedo;
			hit_record.emissive = hr.emissive;
			hit_record.dist = hr.dist;
		}
	}
}


vec3 compute_color_for_ray(Ray ray)
{
	const int MAX_BOUNCE_COUNT = 10;
	vec3 remaining_weight = vec3(1);
	vec3 result = vec3(0);

	for (int bounce = 0; bounce < MAX_BOUNCE_COUNT; ++bounce) {

		HitRecord hit_record;
		intersect_ray_with_world(ray, hit_record);

		if (hit_record.dist == INF_DIST) {
			// We hit the environment.
			vec3 sky_color = mix(vec3(0, 0, 0.4), vec3(0.7, 0.7, 1), ray.dir.y);
			result += sky_color * remaining_weight;
			break;
		}

		result += hit_record.emissive * remaining_weight;
		remaining_weight *= hit_record.albedo;

		if (all(lessThan(remaining_weight, vec3(0.01)))) {
			break;
		}

		// New ray for next iteration
		ray.origin = hit_record.pt + hit_record.normal * RAY_START_BIAS;
		ray.dir = normalize(hit_record.normal + random_unit_vector(rng_state));
	}
	return result;
}





void main()
{
	init_rng();
	const ivec2 screen_size = imageSize(inout_image);
	const ivec2 this_pixel = ivec2(gl_WorkGroupID.x, gl_WorkGroupID.y);

	Ray ray;

	const uint progression_index = PushConstants.progression_index;

	vec2 offset = eval_r2_sequence(progression_index);
	make_primary_ray(offset, ray);

	vec3 color = compute_color_for_ray(ray);
	color = ACESFilm(color);

	vec4 accum_color = imageLoad(inout_image, this_pixel);
	// Branchless condition: if we just started a progression, we treat
	// the accumulation count as 0. This will overwrite the full result with our
	// color, saving us an image clear.
	float accum_count = accum_color.a * float(progression_index > 0);
	vec3 new_accum_rgb = (accum_count * accum_color.rgb + color) / (accum_count + 1);
	new_accum_rgb = min(new_accum_rgb, vec3(1));

	// Not that we can output linear color. We render into an sRGB attachment
	// and get the conversion for free.
	imageStore(inout_image, this_pixel, vec4(new_accum_rgb, accum_count + 1));
}

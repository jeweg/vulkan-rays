#version 450

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

// See https://community.khronos.org/t/drawing-to-image-from-compute-shader-example/7116/2
layout ( binding = 0, rgba8 ) uniform writeonly image2D out_image;

layout(push_constant) uniform PushConstantBlock { float delta_time; } PushConstants;

struct Ray
{
	vec3 origin;
	vec3 dir;
};

vec3 ray_at(Ray ray, float t) 
{
	return ray.origin + ray.dir * t;
}

bool hit_sphere(vec3 center, float radius, Ray ray)
{
	vec3 oc = ray.origin - center;
	float a = dot(ray.dir, ray.dir);
	float b = 2 * dot(oc, ray.dir);
	float c = dot(oc, oc) - radius * radius;
	float discriminant = b*b - 4*a*c;
	return (discriminant > 0);
}

/*
vec3 color(Ray ray) 
{
	if (hit_sphere(vec3(0, 0, -1), 0.5, ray)) {
		return vec3(1, 0, 0);
	}
	vec3 dir_n = normalize(ray.dir);
	float t = 0.5 * (dir_n.y + 1);
	return mix(vec3(1), vec3(0.5, 0.7, 1.0), t);
}
*/

void make_primary_ray(vec2 offset, out Ray out_ray)
{
	// These could come from push constants or a uniform buffer.
	const vec2 screen_dims = vec2(imageSize(out_image));
	const float eye_dist = 2;

	const vec2 this_pixel = vec2(gl_WorkGroupID.x, gl_WorkGroupID.y) - vec2(0.5) + offset;
	const float center_pixel_dx = (2 * this_pixel.x + 1) / screen_dims.x - 1;
	const float center_pixel_dy = (screen_dims.y / screen_dims.x) * (2 * this_pixel.y + 1 - screen_dims.y) / screen_dims.y;

	out_ray.origin = vec3(0);
	out_ray.dir = vec3(center_pixel_dx, center_pixel_dy, -2);
}

void main()
{
	const ivec2 screen_size = imageSize(out_image);
	const ivec2 this_pixel = ivec2(gl_WorkGroupID.x, gl_WorkGroupID.y);

	Ray ray;
	make_primary_ray(vec2(0, 0), ray);
	vec3 color = vec3(1.0);
	if (hit_sphere(vec3(0, 0, -2), 0.5, ray)) {
		color = vec3(0, 0, 0);
	}
	imageStore(out_image, this_pixel, vec4(color, 1));
}
